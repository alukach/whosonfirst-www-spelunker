{% set page_title = doc.properties.get("wof:name") %}
{% extends "base.html" %}
{% block title %}{{ doc.properties.get("wof:id") |e }} | {{ doc.properties.get("wof:name") |e }}{% endblock %}
{% block content %}
<div id="map"></div>
<div class="meta">
<h3>Properties</h3>
<pre>{{ doc['properties'] |pprint|e }}</pre>
<h3>Bounding box</h3>
<pre>{{ doc['bbox'] |pprint|e }}</pre>
</div>

<div class="other">

<h3>Hierarchy</h3>

<h4>Ancestors that {{ doc.properties.get("wof:name") |e }} is parented by</h4>

{% for hierarchy in hierarchies %}
<ul>
{% for w in hierarchy %}
{% if hierarchy[ w ] %}
<li>the {{ w|e }} of <a href="/id/{{ hierarchy[ w ]['properties']['wof:id'] | e }}/">{{ hierarchy[ w ]['properties']['wof:name'] | e }}</a></li>
{% else %}
<li>a <code>{{ w | escape }}</code> that we aren't able to index correctly because... ?</li>
{% endif %}
{% endfor %}
</ul>
{% endfor %}

<h4>Other</h4>
<ul>
<li><a href="/id/{{ doc.properties.get("wof:id") |e }}/descendants/">See all the descendants of {{ doc.properties.get("wof:name") | e }}</a></li>

<li><a href="https://54.148.56.3/?latitude={{ doc.properties.get("geom:latitude") |e }}&longitude={{ doc.properties.get("geom:longitude") |e }}" target="_reversegeo">Reverse geocode</a> ({{ doc.properties.get("geom:latitude") |e }}, {{ doc.properties.get("geom:longitude") |e }})</li>

</ul>

</div>

<div class="geom">{{ doc['geometry'] |e }}</div>
<script type="text/javascript">

window.onload = function(e){

	var map = L.map('map');

{% if doc.bbox.1 == doc.bbox.3 and doc.bbox.0 == doc.bbox.2 %}
	map.setView([{{ doc.bbox.1|e}} , {{ doc.bbox.0|e}} ], 14)
{% else %}
	map.fitBounds([[{{ doc.bbox.1|e }},{{ doc.bbox.0|e }}], [ {{ doc.bbox.3|e }}, {{ doc.bbox.2|e }} ]]);
{% endif %}

	var tangram = Tangram.leafletLayer({
		scene: "{{ url_for('static', filename='scene.yaml') }}",
	        numWorkers: 2,
        	unloadInvisibleTiles: false,
	        updateWhenIdle: false
	});

	tangram.addTo(map);

	var boundary_bbox = {
		"color": "#72A0C1",
		"weight": 3,
		"opacity": 1
	};

	var boundary_poly = {
		"color": "#ff7800",
		"weight": 3,
		"opacity": 1
	};

	var point_style = {
		"color": "#ff7800",
		"weight": 3,
		"opacity": 1
	};

	var pt = {
		'type': 'Feature',
		'geometry': { 'type': 'Point', 'coordinates' : [ {{ doc.properties.get("geom:longitude") |e }}, {{ doc.properties.get("geom:latitude") |e }}] }
	}
console.log(pt);

	var geojson = L.geoJson(pt, {
		'style': boundary_poly,
		pointToLayer: function (feature, latlng) {
	            return L.circleMarker(latlng, point_style);
		}
	});

	geojson.addTo(map);

	var remote = "https://s3.amazonaws.com/com.mapzen.gazetteer/{{ doc.properties['wof:path'] |e }}";

	var req = new XMLHttpRequest();

	// sudo put me in a generic function...

	req.onload = function(){
		var geojson = JSON.parse(this.responseText);
	        var bbox = geojson['bbox'];

	        var sw = [bbox[1], bbox[0]];
        	var ne = [bbox[3], bbox[2]];

        var bounds = new L.LatLngBounds([sw, ne]);
        var current = map.getBounds();

        var redraw = false;

        if (bounds.getSouth() > current.getSouth()){
            redraw = true;
        }

        else if (bounds.getWest() > current.getWest()){
            redraw = true;
        }

        else if (bounds.getNorth() < current.getNorth()){
            redraw = true;
        }

        else if (bounds.getEast() < current.getEast()){
            redraw = true;
        }

        else {}

        if (redraw){
            map.fitBounds(bounds);
        }

		geojson = L.geoJson(geojson, {'style': boundary_poly});
		geojson.addTo(map);
	};

        console.log("fetch " + remote);

        try {				    
	   req.open("get", remote, true);
	   req.send();
        }
				    
        catch(e){
           console.log("failed to fetch " + remote);				    
           console.log(e);				    
        }				    
};
</script>
{% endblock %}
